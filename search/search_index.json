{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>This site is a collection of sharing of learnings and knowledge in my leisure exploration of technologies in programming, software development and perhaps occasionally on my 3d printing.</p>"},{"location":"about/","title":"About Me","text":"<p>Started programming with assembly language.  Did my uni courses mostly with C and X Windows time. Used mostly Java in my career.</p>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/technology/setting-up-log-monitoring-using-grafana-and-loki/","title":"Setting up log monitoring using Grafana and Loki","text":"","tags":["under construction"]},{"location":"blog/technology/setting-up-log-monitoring-using-grafana-and-loki/#log-monitoring","title":"Log monitoring","text":"","tags":["under construction"]},{"location":"blog/technology/reviving-and-old-jetson-nano/","title":"Reviving and old Jetson Nano","text":"","tags":["under construction"]},{"location":"blog/technology/reviving-and-old-jetson-nano/#summary-of-learnings-ai-model-deployment-on-nvidia-jetson-nano","title":"Summary of Learnings: AI Model Deployment on NVIDIA Jetson Nano","text":"<p>This document summarizes the key technical learnings from the process of deploying a TensorFlow-based object detection model on an NVIDIA Jetson Nano. The process involved troubleshooting a series of dependency, compilation, and model compatibility issues.</p>","tags":["under construction"]},{"location":"blog/technology/reviving-and-old-jetson-nano/#1-the-jetson-nano-software-environment","title":"1. The Jetson Nano Software Environment","text":"<p>The process highlighted the characteristics of the Jetson Nano's software environment and its constraints.</p> <ul> <li>Inference-Optimized Architecture: The hardware is designed for running pre-trained models (inference), which explains why compiling libraries from source is a slow and memory-intensive process.</li> <li>Toolchain Versioning: The JetPack SDK is based on older, stable versions of tools (e.g., Python 3.6, g++ 7.x, and cmake 3.10). This creates compatibility conflicts when attempting to install modern AI libraries that have newer requirements.</li> <li>AArch64 Architecture: The <code>aarch64</code> (ARM64) architecture requires specifically compiled software packages. This was the cause of the <code>Illegal instruction</code> error and necessitated the use of official NVIDIA-provided wheels for TensorFlow.</li> </ul>","tags":["under construction"]},{"location":"blog/technology/reviving-and-old-jetson-nano/#2-dependency-management-and-problem-solving","title":"2. Dependency Management and Problem Solving","text":"<p>A series of dependency issues were encountered and solved, establishing a troubleshooting methodology.</p> <ul> <li> <p>Problem: Python Package Incompatibility.</p> <ul> <li>Observation: The latest versions of packages on the Python Package Index (PyPI) are often not compatible with the Jetson's default Python 3.6.</li> <li>Examples Solved: <code>protobuf</code> requiring Python 3.7+, <code>onnx-simplifier</code> requiring a newer <code>onnxruntime</code>.</li> <li>Solution: Manually installing older, specific package versions (e.g., <code>pip install onnx==1.11.0</code>).</li> </ul> </li> <li> <p>Problem: Missing System-Level Libraries.</p> <ul> <li>Observation: Python packages with C++ backends often depend on system libraries that must be installed with <code>apt-get</code>.</li> <li>Examples Solved: <code>h5py</code> failing to build without <code>libhdf5-dev</code>, <code>protobuf</code> failing to build without <code>protobuf-compiler</code>.</li> <li>Solution: Reading build logs to identify missing files and installing the corresponding <code>-dev</code> package.</li> </ul> </li> <li> <p>Problem: Build Tool Incompatibility.</p> <ul> <li>Observation: The tools used to build packages, such as <code>Cython</code> and <code>cmake</code>, also have version dependencies.</li> <li>Examples Solved: <code>numpy</code> failing to build because the default <code>Cython</code> was too new; <code>onnx-simplifier</code> failing because the system <code>cmake</code> was too old.</li> <li>Solution: Manually installing a specific version of the build tool (e.g., <code>pip install Cython==0.29.36</code>) or upgrading the system tool itself.</li> </ul> </li> </ul>","tags":["under construction"]},{"location":"blog/technology/reviving-and-old-jetson-nano/#3-the-model-conversion-pipeline","title":"3. The Model Conversion Pipeline","text":"<p>The conversation detailed the multi-stage process of preparing a model for the Jetson platform.</p> <ul> <li>The Workflow: The required workflow is TensorFlow -&gt; ONNX -&gt; TensorRT.</li> <li>The Protobuf Performance Requirement: The <code>protobuf</code> library's C++ accelerated backend is necessary for acceptable performance during model conversion. The solution involved building the library from source to create and install this backend.</li> <li>Required Model Patching: The ONNX model generated from TensorFlow was not directly compatible with TensorRT and required two modifications via custom Python scripts:<ol> <li>Changing the model's input data type from <code>UINT8</code> to <code>FP32</code>.</li> <li>Changing the model's internal parameters and graph definitions from <code>INT64</code> to <code>INT32</code>.</li> </ol> </li> <li>TensorRT Engine Portability: The final <code>.engine</code> file is compiled for a specific device and software version. This is why the original pre-built engine failed and why a new one had to be generated on the device.</li> </ul>","tags":["under construction"]},{"location":"blog/technology/reviving-and-old-jetson-nano/#4-troubleshooting-principles","title":"4. Troubleshooting Principles","text":"<p>Several troubleshooting techniques were used to resolve the issues.</p> <ul> <li>Error Log Analysis: Each solution was derived from reading the error logs to find the root cause, from <code>FileNotFoundError</code> to <code>TypeError: does not support assignment</code>.</li> <li>Virtual Environment Behavior: The process highlighted how virtual environments function, specifically that <code>sudo pip install</code> targets the system's Python, not the active environment, and that file permissions can get mixed between the user and root.</li> <li>Clean Build Environment: When permissions became tangled, the solution was to delete the source directory (<code>sudo rm -rf protobuf</code>) and start the build process from a clean state.</li> <li>API-Specific Object Manipulation: It was discovered that the <code>RepeatedCompositeContainer</code> object in the ONNX library, while list-like, does not support methods like <code>.clear()</code> or slice assignment (<code>[:] =</code>). The correct manipulation required iterating with <code>del</code> and then using the <code>.extend()</code> method.</li> </ul>","tags":["under construction"]},{"location":"blog/archive/2024/","title":"Jun 2024","text":""},{"location":"blog/category/technology/","title":"Technology","text":""},{"location":"blog/category/web-development/","title":"Web Development","text":""}]}